
model {	
   # priors on parameters for gaussian process
   gp_scaleInv ~ dgamma(0.01,0.01); # shared btw normal/fat
   gp_scale <- 1/gp_scaleInv;
   gp_sigmaSqInv_norm ~ dgamma(0.01,0.01); # prior on normal var parameter
   gp_sigmaSq_norm <- 1/gp_sigmaSqInv_norm; 
   #gp_jitterSqInv ~ dgamma(0.01,0.01); # shared btw normal/fat 	
   gp_jitterSq <- 0;#1/gp_jitterSqInv;

   # This builds the 2 cov matrices needed
   # SigmaKnots is the COV matrix btween knots
   # SigmaOffDiag is the COV matrix between new locations and knots, e.g. it's (100 x 10)   
   for(i in 1:nKnots) {
   	for(j in 1:nKnots) {
        # this adds some jitter to the diagonal but not the off-diags
  	 SigmaKnotsNorm[i,j] <- (1-diagKnots[i,j]) * gp_sigmaSq_norm * exp(-gp_scale * distKnotsSq[i,j]) + diagKnots[i,j] * (gp_jitterSq + gp_sigmaSq_norm);
	
  	}
   }
   for(i in 1:nLocs) {
   	for(j in 1:nKnots) {
  	 SigmaOffDiagNorm[i,j] <- gp_sigmaSq_norm * exp(-gp_scale * distKnots21Sq[i,j]);
   	}
   }	
   invSigmaKnotsNorm <- inverse(SigmaKnotsNorm[,]); # inverse of matrix for projection and mvn distribution

   # Spatial random effects. MVT needs to be constructed manually, because of 
   # well known problems with mvt() in JAGS. See discussions like this one:
   # http://sourceforge.net/p/mcmc-jags/discussion/610037/thread/491d9ccc/?limit=25
   #spatialEffectsKnotsNorm[1:nKnots,1] ~ dmnorm(muZeros, invSigmaKnotsNorm);
   #DF <- 2;
   #scale.df ~ dchisq(DF);
   #spatialEffectsKnotsNorm[1:nKnots,1] <- spatialEffectsKnotsNorm.mvn[1:nKnots,1] * sqrt(DF/scale.df);
   #spatialEffects[1:nLocs,1] <- (SigmaOffDiagNorm %*% invSigmaKnotsNorm) %*% spatialEffectsKnotsNorm[1:nKnots,1];
   
   df <- 1;#~ dexp(0.01);
   scale.df ~ dchisq(df);
   for(t in 1:nT) {
   spatialEffectsKnotsNorm.mvn[1:nKnots,t] ~ dmnorm(muZeros, invSigmaKnotsNorm);
   spatialEffectsKnotsNorm[1:nKnots,t] <- spatialEffectsKnotsNorm.mvn[1:nKnots,t] * sqrt(df/scale.df)
   spatialEffects[1:nLocs,t] <- (SigmaOffDiagNorm %*% invSigmaKnotsNorm) %*% spatialEffectsKnotsNorm[1:nKnots,t];
   }

   # evaluate the likelihood
   for(i in 1:20) { 
   for(j in 1:31) {
       y[i,j] ~ dnorm(spatialEffects[j,i], 10000);
   }
   }    
   
}  