---
title: "Comparing MVN and MVT spatial random effects"
output:
  pdf_document:
    fig_caption: yes
---

The objective of this is to simulate a model with multivariate-T spatial random effects, and evaluate whether that model does a better job than the conventional random effects model (Multivariate normal).

```{r chunkSet, cache=FALSE, echo=FALSE,warning=FALSE,message=FALSE,results="hide"}
library(cluster)
library(mvtnorm)
library(R2jags)
library(fields)
library(ggplot2)
library(knitr)
library(MASS)
library(rstan)
opts_chunk$set(tidy=TRUE, message=FALSE,warning=FALSE)
rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())
```

## Spatial data simulation 

```{r function}

nDataPoints = 100
grid = cbind("lon" = runif(nDataPoints, 5, 15), 
  "lat" = runif(nDataPoints, 5, 15))
nLocs = dim(grid)[1]

simulateData = function(nKnots = 10, gp_scale = 0.3, sigma_t = 0.15, 
  nDraws = 1000, mvt = TRUE, df = 3) {

  # cluster analysis to determine knot locations
  knots = jitter(pam(grid,nKnots)$medoids)
  distKnots = as.matrix(dist(knots))
  distKnotsSq = distKnots^2 # squared distances

  corKnots = exp(-gp_scale*distKnotsSq)
  sigmaKnots = sigma_t * sigma_t * corKnots
  invSigmaKnots = solve(sigmaKnots)
  # Calculate distance from knots to grid
  distAll = as.matrix(dist(rbind(grid, knots)))^2
  distKnots21Sq = t(distAll[-c(1:nLocs), -c((nLocs+1):ncol(distAll))])
  Sigma21 = exp(-gp_scale*distKnots21Sq) * sigma_t * sigma_t
  
  # Generate vector of random effects
  # each 'draw' here is hypothetical draw from posterior
  if(mvt==TRUE) reKnots = mvtnorm::rmvt(nDraws, sigma = sigmaKnots, df = df)
  if(mvt==FALSE) reKnots = mvtnorm::rmvnorm(nDraws, sigma = sigmaKnots)
  
  # if(mvt==TRUE) {
  #   MVN <- MASS::mvrnorm(nDraws, rep(0, ncol(sigmaKnots)), sigmaKnots)
  #   reKnots <- t(t(MVN / sqrt(df / stats::rchisq(n, df))))
  # } else {
  #   reKnots = MASS::rmvnorm(nDraws, rep(0, ncol(sigmaKnots)), sigmaKnots)
  # }
  
  # Project random effects to locations of the data
  proj = t((Sigma21 %*% invSigmaKnots) %*% t(reKnots))
  return(list(knots = knots, reKnots = reKnots, proj = proj, distKnotsSq = distKnotsSq, distKnots21Sq = distKnots21Sq, sigmaKnots = sigmaKnots))
}
```

```{r mvt-alternative-check, eval=FALSE, echo=FALSE}
## http://stats.stackexchange.com/questions/68476/drawing-from-the-multivariate-students-t-distribution
## mu <- c(7, 5)
## sigma <- matrix(c(1, 1/2, 1/2, 1), 2)
## nu <- 1
## n <- 1e3 # Number of draws
## set.seed(1)
## MVN <- MASS::mvrnorm(n, rep(0, length(mu)), sigma)
## set.seed(123)
## y1 <- t(t(MVN / sqrt(nu / stats::rchisq(n, nu))) + mu)
## set.seed(123)
## nu <- 1.05
## y2 <- t(t(MVN / sqrt(nu / stats::rchisq(n, nu))) + mu)
## # par(mfrow = c(1, 2))
## # plot(y1)
## # plot(y2)
## plot(y1[,1], y1[,1] - y2[,1]);abline(a = 0, b = 0)
```

## Checking projection for MVT spatial model

We can visually check to see that the simulation is working ok,  
```{r check-projection, echo=FALSE}
set.seed(1)
dataSim = simulateData(nKnots = 30, nDraws = 2, gp_scale = 0.5, mvt=TRUE)

if(dim(dataSim$reKnots)[1]==1) {
  dataSim$reKnots = t(dataSim$reKnots)
  dataSim$proj = t(dataSim$proj)
}

k <- data.frame(dataSim$knots, v = t(dataSim$reKnots)[,1], type = "knots")
p <- data.frame(grid, v = t(dataSim$proj)[,1], type = "projection")
d <- rbind(k, p)
ggplot(d, aes(lon, lat, colour = v)) + facet_wrap(~type) +
  geom_point(size=3) + scale_colour_gradient2()
```

We can also create several other permutations of the same dataset. We're interested first in exploring density of knots. Second, we're interested in exploring varying degrees of observation error.

\break  
  
## Verify that the MVN - Normal model can recover parameters

We'll look at the ability to recover random effects deviations at knot locations. This is a low CV scenario (0.01) and everything with the estimation looks fine.  

```{r stan_mvtNormal, cache=TRUE, echo=FALSE, warning=FALSE,message=FALSE,results="hide"}
set.seed(1)
dataSim = simulateData(nKnots = 30, nDraws = 2, gp_scale = 0.5, mvt=FALSE)
# gamma assumes constant cv (below so we'll use similar procedure to generate normal devs)
CV = 0.01
y.norm = rnorm(ncol(dataSim$proj), dataSim$proj[1,], sd= CV * abs(dataSim$proj[1,]))  

spatglm_data = list("nKnots"=nrow(dataSim$knots), "nLocs"=nLocs, "N"=nLocs, "nT" = 1, "y" = y.norm, "location" = seq(1, nLocs), "distKnotsSq" = dataSim$distKnotsSq, "distKnots21Sq" = dataSim$distKnots21Sq)
# parameters to monitor
spatglm_pars = c("spatialEffectsKnots", "gp_scale", "gp_sigmaSq", "scaledf", "sigma","spatialEffects")

# fit the model
stanMod_mvnNormal_1 = stan(file = 'mvnNormal.stan',data = spatglm_data, 
  verbose = TRUE, chains = 3, thin = 1, warmup = 300, iter = 600, 
  pars = spatglm_pars)
est <- extract(stanMod_mvnNormal_1, permuted = TRUE)

# we can recover the spatial random deviates really well,
par(mfrow = c(2,1), mai=c(0.7,0.7,0.2,0.1), mgp=c(2,1,0))
plot(dataSim$reKnots[1,], apply(est$spatialEffectsKnots[,1,],2,mean), xlab="True values", ylab="Estimated", main="RE @ knots, MVN-normal model")
abline(0,1, col="red")

# We can also plot the predicted vs true values, 
plot(apply(est$spatialEffects[,1,], 2, mean), y.norm, xlab="Predicted", ylab="Observed", main = "MVN-normal model")
abline(0,1, col="red")
```

\break  
  
## Verify that the MVT - Normal model can recover parameters 

Again, this is a low CV scenario (0.01) and changing the spatial field to the t-distribution appears to work fine.  

```{r stan_mvtNormal2, cache=TRUE, echo=FALSE, warning=FALSE,message=FALSE,results="hide"}
set.seed(1)
dataSim = simulateData(nKnots = 30, nDraws = 2, gp_scale = 0.5, mvt=TRUE)
# gamma assumes constant cv (below so we'll use similar procedure to generate normal devs)
CV = 0.01
y.norm = rnorm(ncol(dataSim$proj), dataSim$proj[1,], sd= CV * abs(dataSim$proj[1,]))  

spatglm_data = list("nKnots"=nrow(dataSim$knots), "nLocs"=nLocs, "N"=nLocs, "nT" = 1, "y" = y.norm, "location" = seq(1, nLocs), "distKnotsSq" = dataSim$distKnotsSq, "distKnots21Sq" = dataSim$distKnots21Sq)
# parameters to monitor
spatglm_pars = c("spatialEffectsKnots", "gp_scale", "gp_sigmaSq", "scaledf", "gammaA","spatialEffects")

# fit the model
stanMod_mvtNormal_1 = stan(file = 'mvtNormal.stan',data = spatglm_data, 
  verbose = TRUE, chains = 3, thin = 1, warmup = 300, iter = 600, 
  pars = spatglm_pars)
est <- extract(stanMod_mvtNormal_1, permuted = TRUE)

par(mfrow = c(2,1), mai=c(0.7,0.7,0.2,0.1), mgp=c(2,1,0))
plot(dataSim$reKnots[1,], apply(est$spatialEffectsKnots[,1,],2,mean), xlab="True values", ylab="Estimated", main="RE @ knots, MVT-normal model")
abline(0,1, col="red")

# We can also plot the predicted vs true values, 
plot(apply(est$spatialEffects[,1,], 2, mean), y.norm, xlab="Predicted", ylab="Observed", main = "MVT-normal model")
abline(0,1, col="red")
```

\break   
  
## Verify that the MVT - Gamma model can recover parameters 

Now we'll switch the observation model to a Gamma model. The CV will remain at the low scenario (0.01) and the estimation appears to work great.     

```{r stan_mvtGamma1, cache=TRUE, echo=FALSE, warning=FALSE,message=FALSE,results="hide"}
set.seed(1)
dataSim = simulateData(nKnots = 30, nDraws = 2, gp_scale = 0.5, mvt=TRUE)
# gamma parameterized in terms of shape and rate. E[y] = a/b, Var = a/b2
# CV = 1/sqrt(gamma.a). So gamma.a = (1/CV2)
CV = 0.01
gamma.a = 1/(CV^2)
gamma.b = gamma.a/exp(t(dataSim$proj)[,1])
y.gamma = rgamma(ncol(dataSim$proj), shape = gamma.a, rate = gamma.b)

spatglm_data = list("nKnots"=nrow(dataSim$knots), "nLocs"=nLocs, "N"=nLocs, "nT" = 1, "y" = y.gamma, "location" = seq(1, nLocs), "distKnotsSq" = dataSim$distKnotsSq, "distKnots21Sq" = dataSim$distKnots21Sq)
# parameters to monitor
spatglm_pars = c("spatialEffectsKnots", "gp_scale", "gp_sigmaSq", "scaledf", "gammaA","spatialEffects")

# fit the model
stanMod_mvtGamma_1 = stan(file = 'mvtGamma.stan',data = spatglm_data, 
  verbose = TRUE, chains = 3, thin = 1, warmup = 300, iter = 600, 
  pars = spatglm_pars)
est <- extract(stanMod_mvtGamma_1, permuted = TRUE)

par(mfrow = c(2,1), mai=c(0.7,0.7,0.2,0.1), mgp=c(2,1,0))
plot(dataSim$reKnots[1,], apply(est$spatialEffectsKnots[,1,],2,mean), xlab="True values", ylab="Estimated", main="RE @ knots, MVT-gamma model")
abline(0,1, col="red")

# We can also plot the predicted vs true values, 
plot(apply(est$spatialEffects[,1,], 2, mean), y.norm, xlab="Predicted", ylab="Observed", main = "MVT-gamma model")
abline(0,1, col="red")
```
  
\break  

## Examine whether MVT-gamma model is more easily corrupted by observation error compared to MVT-normal model

One question is whether the choice of observation model affects our ability to recover the spatial field. To examine this, we'll compare a MVT-normal model to a MVT-gamma model on the same data set with the same random seed (30 knots, 100 data points, CV = 0.15). Here it seems that the gamma observation model makes it a bit harder to recover the spatial field. This will likely be more exaggerated for the binomial model. The plot here shows predicted vs observed, and a similar plot ( not shown ) of true versus estimated random effects shows the same pattern.    

```{r stan_mvtGamma, cache=TRUE, echo=FALSE, warning=FALSE,message=FALSE,results="hide"}
set.seed(1)
dataSim = simulateData(nKnots = 30, nDraws = 2, gp_scale = 0.5, mvt=TRUE)
# gamma parameterized in terms of shape and rate. E[y] = a/b, Var = a/b2
# CV = 1/sqrt(gamma.a). So gamma.a = (1/CV2)
CV = 0.15
gamma.a = 1/(CV^2)
gamma.b = gamma.a/exp(t(dataSim$proj)[,1])
y.gamma = rgamma(ncol(dataSim$proj), shape = gamma.a, rate = gamma.b)

spatglm_data = list("nKnots"=nrow(dataSim$knots), "nLocs"=nLocs, "N"=nLocs, "nT" = 1, "y" = y.gamma, "location" = seq(1, nLocs), "distKnotsSq" = dataSim$distKnotsSq, "distKnots21Sq" = dataSim$distKnots21Sq)
# parameters to monitor
spatglm_pars = c("spatialEffectsKnots","spatialEffects")

# fit the model
stanMod_mvtGamma_2 = stan(file = 'mvtGamma.stan',data = spatglm_data, 
  verbose = TRUE, chains = 3, thin = 1, warmup = 300, iter = 600, 
  pars = spatglm_pars)

set.seed(1)
dataSim = simulateData(nKnots = 30, nDraws = 2, gp_scale = 0.5, mvt=TRUE)
# gamma parameterized in terms of shape and rate. E[y] = a/b, Var = a/b2
# CV = 1/sqrt(gamma.a). So gamma.a = (1/CV2)
CV = 0.15
y.norm = rnorm(ncol(dataSim$proj), dataSim$proj[1,], sd= CV * abs(dataSim$proj[1,]))  

spatglm_data = list("nKnots"=nrow(dataSim$knots), "nLocs"=nLocs, "N"=nLocs, "nT" = 1, "y" = y.norm, "location" = seq(1, nLocs), "distKnotsSq" = dataSim$distKnotsSq, "distKnots21Sq" = dataSim$distKnots21Sq)
# parameters to monitor
spatglm_pars = c("spatialEffectsKnots","spatialEffects")

# fit the model
stanMod_mvtNorm_2 = stan(file = 'mvtNormal.stan',data = spatglm_data, 
  verbose = TRUE, chains = 3, thin = 1, warmup = 300, iter = 600, 
  pars = spatglm_pars)

#par(mfrow = c(2,1), mai=c(0.7,0.7,0.2,0.1), mgp=c(2,1,0))
#est <- extract(stanMod_mvtGamma_2, permuted = TRUE)
#plot(dataSim$reKnots[1,], apply(est$spatialEffectsKnots[,1,],2,mean), xlab="True values", ylab="Estimated", main="RE @ #knots, MVT-gamma model")
#abline(0,1, col="red")

#est <- extract(stanMod_mvtNorm_2, permuted = TRUE)
#plot(dataSim$reKnots[1,], apply(est$spatialEffectsKnots[,1,],2,mean), xlab="True values", ylab="Estimated", main="RE @ #knots, MVT-normal model")
#abline(0,1, col="red")

# We can also plot the predicted vs true values, 
par(mfrow = c(2,1), mai=c(0.7,0.7,0.2,0.1), mgp=c(2,1,0))
est <- extract(stanMod_mvtNorm_2, permuted = TRUE)
plot(apply(est$spatialEffects[,1,], 2, mean), y.norm, xlab="Predicted", ylab="Observed", main = "MVT-normal model")
abline(0,1, col="red")
est <- extract(stanMod_mvtGamma_2, permuted = TRUE)
plot(exp(apply(est$spatialEffects[,1,], 2, mean)), y.gamma, xlab="Predicted", ylab="Observed", main = "MVT-gamma model")
abline(0,1, col="red")
```

### Does increasing the density of knots improve estimates for the gamma model? 

One option for generating better estimates for the MVT-gamma model may be to increase the density of the knots. Taking the same dataset as above, we can compare the base case model (30 knots) to one that has twice as many (60 knots). This plot shows little difference between the two -- increasing the knot density doesn't solve the problems with predictions.  

```{r stan_mvtGamma50, cache=TRUE, echo=FALSE, warning=FALSE,message=FALSE,results="hide"}
set.seed(1)
dataSim = simulateData(nKnots = 30, nDraws = 2, gp_scale = 0.5, mvt=TRUE)
# gamma parameterized in terms of shape and rate. E[y] = a/b, Var = a/b2
# CV = 1/sqrt(gamma.a). So gamma.a = (1/CV2)
CV = 0.15
gamma.a = 1/(CV^2)
gamma.b = gamma.a/exp(t(dataSim$proj)[,1])
y.gamma = rgamma(ncol(dataSim$proj), shape = gamma.a, rate = gamma.b)

# assing new knots -- 60 of them
dataSim$knots = pam(grid, k = 60)$medoids
dataSim$distKnots = as.matrix(dist(dataSim$knots))
dataSim$distKnotsSq = dataSim$distKnots^2 # squared distances
dataSim$distAll = as.matrix(dist(rbind(grid, dataSim$knots)))^2
dataSim$distKnots21Sq = t(dataSim$distAll[-c(1:nLocs), -c((nLocs+1):ncol(dataSim$distAll))])
  
spatglm_data = list("nKnots"=nrow(dataSim$knots), "nLocs"=nLocs, "N"=nLocs, "nT" = 1, "y" = y.gamma, "location" = seq(1, nLocs), "distKnotsSq" = dataSim$distKnotsSq, "distKnots21Sq" = dataSim$distKnots21Sq)
# parameters to monitor
spatglm_pars = c("spatialEffectsKnots", "spatialEffects")

# fit the model
stanMod_mvtGamma_3 = stan(file = 'mvtGamma.stan',data = spatglm_data, 
  verbose = TRUE, chains = 3, thin = 1, warmup = 300, iter = 600, 
  pars = spatglm_pars)

# We can also plot the predicted vs true values, 
par(mfrow = c(2,1), mai=c(0.7,0.7,0.2,0.1), mgp=c(2,1,0))
est <- extract(stanMod_mvtGamma_2, permuted = TRUE)
plot(exp(apply(est$spatialEffects[,1,], 2, mean)), y.gamma, xlab="Predicted", ylab="Observed", main = "MVT-gamma model (30 knots)")
abline(0,1, col="red")
est <- extract(stanMod_mvtGamma_3, permuted = TRUE)
plot(exp(apply(est$spatialEffects[,1,], 2, mean)), y.gamma, xlab="Predicted", ylab="Observed", main = "MVT-gamma model (60 knots)")
abline(0,1, col="red")
```

  
```{r stan_gaussGamma, cache=TRUE, eval=FALSE}
# Named list of data
spatglm_data = list("nKnots"=nKnots, "nLocs"=nLocs, "N"=nLocs, "nT" = 1, "y" = y.gamma, "location" = seq(1, nLocs), "distKnotsSq" = distKnotsSq, "distKnots21Sq" = distKnots21Sq)
# parameters to monitor
spatglm_pars = c("gp_scale", "spatialEffectsKnots", "gp_sigmaSq", "jitter_sq")

# fit the model
stanMod_gaussianGamma = stan(file = 'gaussianGamma.stan',data = spatglm_data, 
  verbose = TRUE, chains = 4, thin = 1, warmup = 500, iter = 1000, 
  pars = spatglm_pars)
```
  
```{r stan_mvtGamma2, cache=TRUE, eval=FALSE}
# Named list of data
spatglm_data = list("nKnots"=nKnots, "nLocs"=nLocs, "N"=nLocs, "nT" = 1, "y" = y.norm, "location" = seq(1, nLocs), "distKnotsSq" = distKnotsSq, "distKnots21Sq" = distKnots21Sq)
# parameters to monitor
spatglm_pars = c("gp_scale", "spatialEffectsKnots", "gp_sigmaSq", "jitter_sq", "scaledf")

# fit the model
stanMod_mvtGamma = stan(file = 'mvtGamma_0616.stan',data = spatglm_data, 
  verbose = TRUE, chains = 4, thin = 1, warmup = 500, iter = 1000, 
  pars = spatglm_pars)

#extract(stanMod_mvtGamma, permuted = FALSE)

est.means = apply(extract(stanMod_mvtGamma, permuted = TRUE)[[2]][,1,], 2, mean)
plot(re.norm, est.means - mean(est.means))
```

## Comparing MVN and MVT random effects with Poisson model (STAN)
  
```{r stan_gaussPois, cache=TRUE, eval=FALSE}
# Named list of data
spatglm_data = list("nKnots"=nKnots, "nLocs"=nLocs, "N"=nLocs, "nT" = 1, 
  "y" = y.poisson, "location" = seq(1, nLocs), "distKnotsSq" = distKnotsSq,
  "distKnots21Sq" = distKnots21Sq)
# parameters to monitor
spatglm_pars = c("gp_scale", "spatialEffectsKnots", "gp_sigmaSq", "jitter_sq")

# fit the model
stanMod_gaussianPoisson = stan(file = 'gaussianPoisson.stan',
  data = spatglm_data, verbose = TRUE, chains = 4, thin = 1, warmup = 500, 
  iter = 1000, pars = spatglm_pars)
```


```{r stan_mvtPois, cache=TRUE, eval=FALSE}
# Named list of data
spatglm_data = list("nKnots"=nKnots, "nLocs"=nLocs, "N"=nLocs, "nT" = 1, 
  "y" = y.poisson, "location" = seq(1, nLocs), "distKnotsSq" = distKnotsSq,
  "distKnots21Sq" = distKnots21Sq)
# parameters to monitor
spatglm_pars = c("gp_scale", "spatialEffectsKnots", "gp_sigmaSq", "jitter_sq")

# fit the model
stanMod_mvtPoisson = stan(file = 'mvtPoisson.stan',data = spatglm_data, 
  verbose = TRUE, chains = 4, thin = 1, warmup = 500, iter = 1000, 
  pars = spatglm_pars)
```

### Simulating data with Poisson observation model

```{r, fig.pos="placeHere",fig.cap="Simulated Poisson data, using MVT random effects."}
# Include observation error
# simulate observed data on grid
y.poisson = rpois(ncol(dataSim$proj), exp(t(dataSim$proj)[,1]))  

hist(y.poisson, 40, col="grey", xlab="Simulated data", main="")
```

\break

## Try model mismatch: fit MVT to MVT vs MVN to MVT, is MVT better?

```{r stan_mvtmvn_mismatch, cache=TRUE, echo=FALSE, warning=FALSE, message=FALSE, results="hide"}
# Make sure 'effective' nu is low:
s <- 0
nu_big <- TRUE
while (nu_big) {
  s <- s + 1
  message(paste("seed =", s))
  set.seed(s)
  dataSim <-simulateData(nKnots = 30, nDraws = 1, gp_scale = 0.5, mvt = TRUE, df = 1)
  # alpha = 0 means forced to be symmetrical student-t
  m <- sn::selm(dataSim$reKnots[1,] ~ 1, family = "ST", fixed.param = list(alpha = 0)) 
  # summary(m)
  nu <- sn::coef(m, "dp")[["nu"]]
  message(paste("nu =", round(nu, 1)))
  nu_big <- ifelse(nu > 3, TRUE, FALSE)
}
plot(dataSim$reKnots[1,])

# gamma assumes constant cv (below so we'll use similar procedure to generate normal devs)
CV = 0.01
y.norm = rnorm(ncol(dataSim$proj), dataSim$proj[1,], sd= CV * abs(dataSim$proj[1,]))  

spatglm_data = list("nKnots"=nrow(dataSim$knots), "nLocs"=nLocs, "N"=nLocs, "nT" = 1, "y" = y.norm, "location" = seq(1, nLocs), "distKnotsSq" = dataSim$distKnotsSq, "distKnots21Sq" = dataSim$distKnots21Sq)
# parameters to monitor
spatglm_pars = c("spatialEffectsKnots", "gp_scale", "gp_sigmaSq", "scaledf", "gammaA","spatialEffects")

# fit the model mvt-mvt
stanMod_mvtmvt_1 = stan(file = 'mvtNormal.stan',data = spatglm_data, 
  verbose = TRUE, chains = 3, thin = 1, warmup = 300, iter = 600, 
  pars = spatglm_pars)
est_tt <- extract(stanMod_mvtmvt_1)

# parameters to monitor
spatglm_pars = c("spatialEffectsKnots", "gp_scale", "gp_sigmaSq", "scaledf", "sigma","spatialEffects")

# fit the model mvn-mvt
stanMod_mvnmvt_1 = stan(file = 'mvnNormal.stan',data = spatglm_data, 
  verbose = TRUE, chains = 3, thin = 1, warmup = 300, iter = 600, 
  pars = spatglm_pars)
est_nt <- extract(stanMod_mvnmvt_1)

par(mfrow = c(1,1))
plot(apply(est_tt$spatialEffectsKnots[,1,],2,mean), 
  apply(est_nt$spatialEffectsKnots[,1,],2,mean), 
  xlab="MVT model, MVT data", ylab="MVN model, MVT data")
abline(0,1, col="red")
```

## How exactly does the MVT compare to MVN with a single draw?

For a single draw from the multivariate distributions, 
the MVN and MVT scale linearly with each other.
The MVN usually has more variability but occasionally the
MVT will have much more variability.
The pattern will be exactly the same across the two with
each draw, just scaled one way or the other.
I.e., heavy tails are created across multiple draws not
from a single draw.

```{r}
set.seed(1)
d1 <-simulateData(nKnots = 99, nDraws = 1e3, gp_scale = 0.5, mvt = TRUE, df = 2)
set.seed(1)
d2 <-simulateData(nKnots = 99, nDraws = 1e3, gp_scale = 0.5, mvt = TRUE, df = 1e9)

par(mfrow = c(1, 2))
plot(d1$reKnots, xlim = range(c(d1$reKnots[,1], d2$reKnots[,1])), 
  ylim = range(c(d1$reKnots[,2], d2$reKnots[,2])), 
  col = "#00000010", pch = 19)
plot(d2$reKnots, xlim = range(c(d1$reKnots[,1], d2$reKnots[,1])), 
  ylim = range(c(d1$reKnots[,2], d2$reKnots[,2])), 
  col = "#00000010", pch = 19)

# compare biggest outlier
i <- which(d1$reKnots[,1] == max(d1$reKnots[,1]))
plot(d1$reKnots[i,], d2$reKnots[i,]);abline(a = 0, b = 1)
plot(d1$reKnots[i,], d1$reKnots[i,] - d2$reKnots[i,]);abline(a = 0, b = 0)

k1 <- data.frame(d1$knots, v = as.numeric(d1$reKnots[i,]), type = "MVT")
k2 <- data.frame(d2$knots, v = as.numeric(d2$reKnots[i,]), type = "MVN")
d <- rbind(k1, k2)
ggplot(d, aes(lon, lat, colour = v)) + facet_wrap(~type) +
  geom_point(size=3) + scale_colour_gradient2()

# probably not a huge outlier:
i <- 1
plot(d1$reKnots[i,], d2$reKnots[i,]);abline(a = 0, b = 1)
plot(d1$reKnots[i,], d1$reKnots[i,] - d2$reKnots[i,]);abline(a = 0, b = 0)

k1 <- data.frame(d1$knots, v = as.numeric(d1$reKnots[1,]), type = "MVT")
k2 <- data.frame(d2$knots, v = as.numeric(d2$reKnots[1,]), type = "MVN")
d <- rbind(k1, k2)
ggplot(d, aes(lon, lat, colour = v)) + facet_wrap(~type) +
  geom_point(size=3) + scale_colour_gradient2()
```
