---
title: "Comparing MVN and MVT spatial random effects"
output:
  pdf_document:
    fig_caption: yes
---

The objective of this is to simulate a model with multivariate-T spatial random effects, and evaluate whether that model does a better job than the conventional random effects model (Multivariate normal).

```{r chunkSet, cache=FALSE, echo=FALSE,warning=FALSE,message=FALSE}
library(cluster)
library(mvtnorm)
library(R2jags)
library(fields)
library(ggplot2)
library(knitr)
library(MASS)
library(rstan)
opts_chunk$set(tidy=TRUE, message=FALSE,warning=FALSE)
rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())
```

## Spatial data simulation 

```{r function}
nDataPoints = 100
grid = cbind("lon" = runif(nDataPoints, 5, 15), 
  "lat" = runif(nDataPoints, 5, 15))
nLocs = dim(grid)[1]

simulateData = function(nKnots = 10, gp_scale = 0.3, sigma_t = 0.15, nDraws = 1000, mvt = TRUE) {

  # cluster analysis to determine knot locations
  knots = jitter(pam(grid,nKnots)$medoids)
  distKnots = as.matrix(dist(knots))
  distKnotsSq = distKnots^2 # squared distances

  corKnots = exp(-gp_scale*distKnotsSq)
  sigmaKnots = sigma_t * sigma_t * corKnots
  invSigmaKnots = solve(sigmaKnots)
  # Calculate distance from knots to grid
  distAll = as.matrix(dist(rbind(grid, knots)))^2
  distKnots21Sq = t(distAll[-c(1:nLocs), -c((nLocs+1):ncol(distAll))])
  Sigma21 = exp(-gp_scale*distKnots21Sq) * sigma_t * sigma_t
  
  # Generate vector of random effects
  # each 'draw' here is hypothetical draw from posterior
  if(mvt==TRUE) reKnots = mvtnorm::rmvt(nDraws, sigma = sigmaKnots, df = 3)
  if(mvt==FALSE) reKnots = mvtnorm::rmvnorm(nDraws, sigma = sigmaKnots)
  
  # Project random effects to locations of the data
  proj = t((Sigma21 %*% invSigmaKnots) %*% t(reKnots))
  return(list(knots = knots, reKnots = reKnots, proj = proj, distKnotsSq = distKnotsSq, distKnots21Sq = distKnots21Sq, sigmaKnots = sigmaKnots))
}
```

## Checking projection

We can visually check to see that the simulation is working ok,  
```{r check-projection, echo=FALSE}
set.seed(1)
dataSim = simulateData(nKnots = 30, nDraws = 2, gp_scale = 0.5, mvt=TRUE)

if(dim(dataSim$reKnots)[1]==1) {
  dataSim$reKnots = t(dataSim$reKnots)
  dataSim$proj = t(dataSim$proj)
}

k <- data.frame(dataSim$knots, v = t(dataSim$reKnots)[,1], type = "knots")
p <- data.frame(grid, v = t(dataSim$proj)[,1], type = "projection")
d <- rbind(k, p)
ggplot(d, aes(lon, lat, colour = v)) + facet_wrap(~type) +
  geom_point(size=3) + scale_colour_gradient2()
```

We can also create several other permutations of the same dataset. We're interested first in exploring density of knots. Second, we're interested in exploring varying degrees of observation error.

### Simulating data with Gamma observation model

```{r, fig.pos="placeHere",fig.cap="Simulated gamma data, using MVT random effects."}
# Include observation error
# Use same gamma parameterization as JAGS
gamma.a = 0.03
gamma.b = gamma.a/exp(t(dataSim$proj)[,1])
# simulate observed data 
y.gamma = rgamma(ncol(dataSim$proj), shape = gamma.a, rate = gamma.b)  
#hist(y.gamma, 40, col="grey", xlab="Simulated data", main="")
```
  
## Verify that the MVN - Normal model can recover parameters

We'll look at the ability to recover random effects deviations at knot locations.  

```{r stan_mvtNormal, cache=TRUE, echo=FALSE}

set.seed(1)
dataSim = simulateData(nKnots = 30, nDraws = 2, gp_scale = 0.5, mvt=FALSE)
y.norm = rnorm(ncol(dataSim$proj), dataSim$proj[1,], sd= 0.01)  

spatglm_data = list("nKnots"=nrow(dataSim$knots), "nLocs"=nLocs, "N"=nLocs, "nT" = 1, "y" = y.norm, "location" = seq(1, nLocs), "distKnotsSq" = dataSim$distKnotsSq, "distKnots21Sq" = dataSim$distKnots21Sq)
# parameters to monitor
spatglm_pars = c("spatialEffectsKnots", "gp_scale", "gp_sigmaSq", "scaledf", "sigma","spatialEffects")

# fit the model
stanMod_mvnNormal = stan(file = 'simulationTesting/mvnNormal.stan',data = spatglm_data, 
  verbose = TRUE, chains = 3, thin = 1, warmup = 300, iter = 600, 
  pars = spatglm_pars)
est <- extract(stanMod_mvnNormal, permuted = TRUE)

# we can recover the spatial random deviates really well,
par(mfrow = c(2,1), mai=c(0.7,0.7,0.2,0.1), mgp=c(2,1,0))
plot(dataSim$reKnots[1,], apply(est$spatialEffectsKnots[,1,],2,mean), xlab="True values", ylab="Estimated", main="RE @ knots, MVN-normal model")
abline(0,1, col="red")

# We can also plot the predicted vs true values, 
plot(apply(est$spatialEffects[,1,], 2, mean), y.norm, xlab="Predicted", ylab="Observed", main = "MVN-normal model")
abline(0,1, col="red")
```

## Verify that the MVT - Normal model can recover parameters 

```{r stan_mvtGamma, cache=TRUE, echo=FALSE}
set.seed(1)
dataSim = simulateData(nKnots = 50, nDraws = 2, gp_scale = 0.5, mvt=TRUE)
#gamma.a = 0.03
#gamma.b = gamma.a/exp(t(dataSim$proj)[,1])
#y.gamma = rgamma(ncol(dataSim$proj), shape = gamma.a, rate = gamma.b)
y.norm = rnorm(ncol(dataSim$proj), dataSim$proj[1,], sd= 0.01) 

spatglm_data = list("nKnots"=nrow(dataSim$knots), "nLocs"=nLocs, "N"=nLocs, "nT" = 1, "y" = y.norm, "location" = seq(1, nLocs), "distKnotsSq" = dataSim$distKnotsSq, "distKnots21Sq" = dataSim$distKnots21Sq)
# parameters to monitor
spatglm_pars = c("spatialEffectsKnots", "gp_scale", "gp_sigmaSq", "scaledf", "gammaA","spatialEffects")

# fit the model
stanMod_mvtNormal = stan(file = 'simulationTesting/mvtNormal.stan',data = spatglm_data, 
  verbose = TRUE, chains = 3, thin = 1, warmup = 300, iter = 600, 
  pars = spatglm_pars)
est <- extract(stanMod_mvtNormal, permuted = TRUE)

par(mfrow = c(2,1), mai=c(0.7,0.7,0.2,0.1), mgp=c(2,1,0))
plot(dataSim$reKnots[1,], apply(est$spatialEffectsKnots[,1,],2,mean), xlab="True values", ylab="Estimated", main="RE @ knots, MVT-normal model")
abline(0,1, col="red")

# We can also plot the predicted vs true values, 
plot(apply(est$spatialEffects[,1,], 2, mean), y.norm, xlab="Predicted", ylab="Observed", main = "MVT-normal model")
abline(0,1, col="red")
```

  
```{r stan_gaussGamma, cache=TRUE, eval=FALSE}
# Named list of data
spatglm_data = list("nKnots"=nKnots, "nLocs"=nLocs, "N"=nLocs, "nT" = 1, "y" = y.gamma, "location" = seq(1, nLocs), "distKnotsSq" = distKnotsSq, "distKnots21Sq" = distKnots21Sq)
# parameters to monitor
spatglm_pars = c("gp_scale", "spatialEffectsKnots", "gp_sigmaSq", "jitter_sq")

# fit the model
stanMod_gaussianGamma = stan(file = 'simulationTesting/gaussianGamma.stan',data = spatglm_data, 
  verbose = TRUE, chains = 4, thin = 1, warmup = 500, iter = 1000, 
  pars = spatglm_pars)
```
  
```{r stan_mvtGamma, cache=TRUE}
# Named list of data
spatglm_data = list("nKnots"=nKnots, "nLocs"=nLocs, "N"=nLocs, "nT" = 1, "y" = y.norm, "location" = seq(1, nLocs), "distKnotsSq" = distKnotsSq, "distKnots21Sq" = distKnots21Sq)
# parameters to monitor
spatglm_pars = c("gp_scale", "spatialEffectsKnots", "gp_sigmaSq", "jitter_sq", "scaledf")

# fit the model
stanMod_mvtGamma = stan(file = 'mvtGamma_0616.stan',data = spatglm_data, 
  verbose = TRUE, chains = 4, thin = 1, warmup = 500, iter = 1000, 
  pars = spatglm_pars)

#extract(stanMod_mvtGamma, permuted = FALSE)

est.means = apply(extract(stanMod_mvtGamma, permuted = TRUE)[[2]][,1,], 2, mean)
plot(re.norm, est.means - mean(est.means))
```

## Comparing MVN and MVT random effects with Poisson model (STAN)
  
```{r stan_gaussPois, cache=TRUE}
# Named list of data
spatglm_data = list("nKnots"=nKnots, "nLocs"=nLocs, "N"=nLocs, "nT" = 1, 
  "y" = y.poisson, "location" = seq(1, nLocs), "distKnotsSq" = distKnotsSq,
  "distKnots21Sq" = distKnots21Sq)
# parameters to monitor
spatglm_pars = c("gp_scale", "spatialEffectsKnots", "gp_sigmaSq", "jitter_sq")

# fit the model
stanMod_gaussianPoisson = stan(file = 'gaussianPoisson.stan',
  data = spatglm_data, verbose = TRUE, chains = 4, thin = 1, warmup = 500, 
  iter = 1000, pars = spatglm_pars)
```


```{r stan_mvtPois, cache=TRUE}
# Named list of data
spatglm_data = list("nKnots"=nKnots, "nLocs"=nLocs, "N"=nLocs, "nT" = 1, 
  "y" = y.poisson, "location" = seq(1, nLocs), "distKnotsSq" = distKnotsSq,
  "distKnots21Sq" = distKnots21Sq)
# parameters to monitor
spatglm_pars = c("gp_scale", "spatialEffectsKnots", "gp_sigmaSq", "jitter_sq")

# fit the model
stanMod_mvtPoisson = stan(file = 'mvtPoisson.stan',data = spatglm_data, 
  verbose = TRUE, chains = 4, thin = 1, warmup = 500, iter = 1000, 
  pars = spatglm_pars)
```

### Simulating data with Poisson observation model

```{r, fig.pos="placeHere",fig.cap="Simulated Poisson data, using MVT random effects."}
# Include observation error
# simulate observed data on grid
y.poisson = rpois(ncol(dataSim$proj), exp(t(dataSim$proj)[,1]))  

hist(y.poisson, 40, col="grey", xlab="Simulated data", main="")
```
